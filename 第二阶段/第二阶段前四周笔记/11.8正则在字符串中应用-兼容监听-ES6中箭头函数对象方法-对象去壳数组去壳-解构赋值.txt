$body.innerHTML=''在对象内添加内容，内容如果是标签，不会转义
$body.innerText=" 在对象内添加内容，内容如果是标签，则会进行转义
$body.outHTML="在对象内添加内容，内容如果是标签，不会转义，但是
对象本身就不复存在，被内容给代替了；


正则在字符串中的应用 以下都是字符串的方法
1）replace()支持正则表达式,var str = '123afaflf123jadfaf45fda7af'
字符串中的数字全部转化为***，str.replace(/\d{1,}/g,'***')或者str.replace(/\d+/g,'***')

2)  includes('');查询字符串里是否有字符，输入一个字符，如果存在返回true，不存在返回false;和
indexOf()差不多，只是返回的值不一样罢了，indexOf的加强版

3）search(reg);跟indexOf一样，检测字符所在的索引，
只不过可以使用正则表达式；var str = '1ad1adf1adf4adf2a'，str.search(/\d/)，结果为0；
ie6提供的，indexOf的加强版

4）match(reg);字符串捕获；一次性把满足条件的结果都返回，如果不加g，则和exec（）一样；
 加g的时候var str = '1ad1adf1adf4adf2a'，str.match(/\d/g)，结果返回一个数组["1", "1", "1", "4", "2"]；
不加g的时候var str = '1ad1adf1adf4adf2a'，str.match(/\d/)，结果返回一个数组["1"]；
有了+就有了贪婪性了

5）startWith(参数1，参数2)检测字符串是否是某个字符开头；参数2是从第几个索引开始检测；
参数1是检索的字符串；
6）endWith(参数1，参数2);检测字符串是否是某个字符结尾；参数2是从第几个字符开始检测，从左往右数，从1开始数
参数1是检索的字符串；
7）补充：indexOf(参数1，参数2)；参数1检索字符，参数2开始的位置


正则表达式两个方法和一个属性
test（）检测字符串是否符合正则表达式的规则，如果符合该规则返回true,否则返回false;
exec（）返回满则正则表达式的结果，返回一个数组
lastIndex;正则表达式开始检测的位置，需要正则表达式中添加g;如果不添加 其值永远为0；
text()和exec()使用后lastIndex才有意义 其值才会有所改变 ；

严格模式
1）优点：
减少js代码中不合理的地方，保证js代码的运行安全
提高编译器的效率
为未来js版本做铺垫
 
2）开启严格模式，在作用域最上面写 'use strict'
3)严格模式下规则
a:在严格模式下，不能使用未声明的变量，如若使用则会报错

b:在严格模式下，函数如果没有调用者，this指向null或者undefined;

c:在严格模式下，arguments元素改变，对应的形参不会改变；证明了一个点：
arguments里面的值，跟实参是一一对应，两个没有关系，
在非严格模式下，两者的值会进行同步；


d:在严格模式下，arguments不可以重新赋值,如果重新赋值，则会报错；

f:严格模式下，不可以使用八进制；

e:严格模式下，不能使用with(obj){console.log(name)}语句；在es6中with语句已被删除；

事件监听兼容
1）在IE里；attachEvent(on+事件名称 ，事件处理程序)添加事件，没有
第三个参数，因为IE里只支持冒泡；
2）在IE里；detachEvent();删除事件监听

ES6中------------------------------------------------------------------------

let,const
1）都是声明用的
2）let和var基本一样，声明一个变量，可以更改
3）const 声明一个常量，一旦赋值不可更改；更改就会报错
     一旦声明就要立即赋值；

4）let和const的区别：
前者声明的是变量，后者声明的是常量；

5）let和var的区别：
let声明的变量不可以重复，在同一个作用域，一旦重复就会报错；
let声明的变量不存在变量提升，即不能在声明以前使用变量；简称暂时性死区；
会生成一个块级作用域，所以es6中局部作用域包括函数作用域，块级作用域；

6）声明对象用const 声明局部的变量用let; 


解构赋值：简化代码，没有任何功能；
1）数组中使用结构赋值：var arr = [1,2,3,[4,5]],let [a,b,c,[d,e]]=arr;一一对应；
2）对象中使用结构赋值，如果变量名称冲突即重复，在变量后面：+新的名称，取而代之；
如果想找到对象下面的对象的属性，属性名称：{属性名称}；
3）a和b交换：var a = 10,var b = 20 ,[a,b]=[b,a];
4）应用在函数形参上面；比如
function fn({name,age}){console.log(name,age)}
var obj = {name:'xxx',age:18,height:'175'}
fn(obj);


字符串拓展
1）字符串模板引擎，极大的简化了字符串拼接，可以随意换行；
2）str.repeat()
3）str.includes()
4)）str.starsWith();都是上面讲过的 请看上面的内容即可；


对象的拓展
1）对象的简写方式：如果变量名称，和声明对象的属性一致，想要让变量作为
属性值，在对象中可以只写属性名称，属性值可以省略 就不用写了，比如：
可以省略变量；即var name = 1;obj={name:name}可以简写obj={name}
2）Object.keys(obj);返回对象的所有属性名称，返回一个集合
3）Object.assign(obj1,obj2);合并对象,把后面的对象合并到前面的一个上面，
如果有多个对象，都是合并到第一个上面；
如果后面的对象里属性名称有与第一个对象属性名称一样的则后面的会把第一个的覆盖；

函数的拓展 设置默认值 rest参数 箭头函数
1）rest参数:function fn(a,b,...arg){},fn(1,2,3,4,5,6);arg是一个数组；如果只知道传入
的参数至少是两个时即传入的参数个数不确定时就这样写

2）箭头函数，常引用于高阶函数；arr.map(function(a){return a*a});
用箭头函数可以简写为arr.map(a=>a*a)
A:可以省略function,只写arr.map((a))=>{return a*a;}
B:当函数代码只有一行时，可以省略大括号即arr.map((a)=>return a*a)
C:当函数代码只有一行且是return时，可以省略return和大括号即arr.map((a)=>a*a)
D:当形参只有一个时，可以省略形参所绑定的括号即arr.map(a=>a*a)
E:当没有形参时，括号形参所绑定的括号不能省但是又想省略，
则传入一个没用的形参下划线即arr.map(_=>a*a);

3）补充一个高阶函数，arr.forEach(function(item,index,arr){}),循环数组，没有
任何代码; arr.forEach(item=>console.log(item))

4）函数的this,至于函数的调用方式有关，但是，在箭头函数中this,跟
随上下文（函数声明 的作用域 里面的 this指向）；

5）虽然 箭头函数可以简化代码，但是不可以滥用，因为会改变函数的this指向；

6）设置默认值：
函数如果设置默认值即在函数名后括号里的形参赋值，相当于是let声明；
let规则：未声明的变量不能使用，变量不能提升，会开辟一个块级作用域；

拓展运算符
1）数组去壳：...arr;
对象去壳：...obj;

2）深拷贝：把一个值拷贝给另外一个对象，两者没有任何关系，其中一个
无论如何改变，都不会影响另外一个
      浅拷贝：把一个对象的地址拷贝给另外一个变量，其中一个值改变了，
      另外一个也会改变；


总结：A:对象里的函数以前我是这样写的obj={init:function(){} 现在的我是这样写的obj={ init(){} }
          以前的匿名函数我是这样写的var fn = function(){console.log(1);
          现在用了箭头函数我是这样写var fn = _=>console.log(1)
           B:Object.assign(obj1,obj2);合并对象,把后面的对象合并到前面的一个上面，
           如果有多个对象，都是合并到第一个上面；
           如果后面的对象里属性名称有与第一个对象属性名称一样的则后面的会把第一个的覆盖；

           拓展运算符中的对象去壳...obj;如果在objparent中加入...obj,且objparent里有与obj中的
           属性一样，则obj中的属性会覆盖掉objparent中的属性；

           C：当不确定用户传的实参个数时，我们函数里的形参也就无法确定，这时rest参数就
           来解决啦，...形参，如function fn(...arr){};arr的值是所有实参的集合，且是一个数组；
           
           D:建议const 声明对象，let声明局部变量，var声明全局变量；
























